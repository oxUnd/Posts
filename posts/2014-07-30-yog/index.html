<!doctype html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet" integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin="anonymous">
  <link href="https://www.orrafy.com/css/reset.css?v=1cc0af0" rel="stylesheet">
  <link href="https://www.orrafy.com/css/site.css?v=1cc0af0" rel="stylesheet">
  <link rel="preload" href="https://www.orrafy.com/fonts/blockzone-webfont.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="stylesheet" href="//unpkg.com/heti/umd/heti.min.css">
  
</head>
<body>
  <header id="preamble" class="status heti heti--classic">
    <div class="logo">
      <a href="/">
        <img src="https://0.gravatar.com/avatar/6187fb849f337554f1515012aedd06d55365e8ac6f170cbadfaaf94d5e3790cd?s=80" class="avatar" alt="My icon."/>
      </a>
      <a href="/"><h2>OxUnd. </h2></a>
      <div id="social">
        <a title="dmacvicar on Github" href="https://github.com/oxund">
          <i id="github-icon" class="fa-brands fa-github"></i>
      	</a>
        <a title="RSS feed" id="atom" href="https://www.orrafy.com/posts/rss.xml">
          <i id="rss-icon" class="fa-solid fa-rss"></i>
        </a>
    </div>
 </header>
 <main id="main">
 
<article class="heti heti--classic">
  <h1>&#34;yog，简单易用的node框架&#34;</h1>
  <div class="date">30 Jul 2014</div>
  <div class="content">
    
<section id="outline-container-2014-07-30-yog" class="outline-2">
<h2 id="2014-07-30-yog">2014-07-30-yog</h2>
<div class="outline-text-2">
<p>
风风火火又是一个多月过去了，炎热的北京夏天热得每个人都很浮躁，空调吱呀吱呀，有同事就咆哮大骂起来了，殊不知空调这玩意儿也能让TA生气。说偏了，回到正文。
</p>

<p>
就在着炎热的夏天，项目组开发了一套node的开发框架，<a href="https://github.com/fex-team/yog">yog</a>。
</p>

<p>
<a href="https://github.com/fex-team/yog">yog</a>解决了什么问题呢？
</p>

<ul class="org-ul">
<li>中间件维护问题</li>
<li>路由</li>
<li>bigpipe支持</li>
<li>mvc封装</li>
<li>目录规范</li>
<li>开发模式</li>
</ul>
</div>

<div id="outline-container-中间件维护问题" class="outline-4">
<h4 id="中间件维护问题">中间件维护问题</h4>
<div class="outline-text-4" id="text-中间件维护问题">
<p>
用过=express=的人都知道，中间件维护起来确实挺麻烦；需要以这样
</p>

<div class="org-src-container">
<pre class="src src-javascript">app.use(<span class="org-keyword">static</span>());
app.use(router());
</pre>
</div>

<p>
硬编码的方式挂载中间件；这样假设某一天需要添加中间件时，还得考虑要加载哪两个的中间；所以yog利用配置文件配置进去。
</p>

<div class="org-src-container">
<pre class="src src-json">{
    "middleware": {
        "urlencoded": {
            "enabled": true,
            "priority": 50,
            "module": {
                "arguments": [
                    {
                        "extended": true
                    }
                ]
            }
        }
    }
}
</pre>
</div>

<p>
上面就是一个例子，中间件=urlencoded=以这样一个方式配置到框架中；
</p>
</div>
</div>

<div id="outline-container-路由" class="outline-4">
<h4 id="路由">路由</h4>
<div class="outline-text-4" id="text-路由">
<p>
说到路由，假设用=express=的方式解决的话是如下这个样子的；
</p>

<div class="org-src-container">
<pre class="src src-javascript">app.get(<span class="org-string">'/xxx'</span>, requestHandle);
</pre>
</div>

<p>
如果按照这种方式，所有的路由可能需要写到某一个文件里面；就比如=django=就是配置在一个文件里面的，这样的好处是所有的路由情况都可以一目了然；
但项目大了以后放到同一个地方确实会不方便，一般会选择使用一些规则来命中某一个Action，比如根据URI的信息来做匹配执行代码，这种方法很多框架都使用；
</p>

<p>
而=yog=里面结合了两种方式，先用规则的方式命中某一个=controller=，然后在=controller=中书写关于这个=controller=的路由规则，比如：
</p>

<blockquote>
<p>
<a href="http://127.0.0.1/user/get">http://127.0.0.1/user/get</a>
</p>
</blockquote>

<p>
<i><code>user</code></i> 命中 <code>controllers/user.js</code>
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span class="org-comment-delimiter">//</span><span class="org-comment">user.js
</span>
module.exports = <span class="org-keyword">function</span> (<span class="org-variable-name">router</span>) {
    router.get(<span class="org-string">'/get'</span>, <span class="org-keyword">function</span> (<span class="org-variable-name">req</span>, <span class="org-variable-name">res</span>) {
        <span class="org-comment-delimiter">//</span><span class="org-comment">balabala...
</span>    });
};
</pre>
</div>

<p>
在项目启动的时候，会扫描=controllers=目录下的文件，全部挂载到运行环境中；
</p>

<p>
通过对=中间件=的处理以及=router=的处理；入口文件就相当简单了；
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span class="org-keyword">var</span> <span class="org-variable-name">app</span> = require(<span class="org-string">'express'</span>)();
<span class="org-keyword">var</span> <span class="org-variable-name">yog</span> = require(<span class="org-string">'yog'</span>);

app.use(yog());
app.listen(4000);
</pre>
</div>
</div>
</div>

<div id="outline-container-bigpipe支持" class="outline-4">
<h4 id="bigpipe支持">bigpipe支持</h4>
<div class="outline-text-4" id="text-bigpipe支持">
<p>
关于BigPipe，前面已经写了一篇博文说明<a href="file:///posts/web-dev/quickling-1/">网页加载优化方案：bigpipe，bigrender，lazyrender</a>。
</p>

<p>
以前在PHP里面实现，无法做到并行获取数据，然node就不一样了，可以随意并行，所以<a href="https://github.com/fex-team/yog">yog</a>对bigpipe的支持是很完整的；它可以控制任意一小块页面输出，可以很方便的做性能优化。
</p>

<p>
那是如何实现的呢？
</p>

<p>
具体的实现可以阅读源代码<a href="https://github.com/fex-team/yog-bigpipe">yog-bigpipe</a>。大概总结是这样的；
</p>

<ul class="org-ul">
<li>使用模板的钩子标识每个需要=pipe=出来的区域</li>
<li>渲染时把这些区域抠出来，留个占位符=&lt;div id=&ldquo;id_100&rdquo;&gt;&lt;/div&gt;=</li>
<li>后获取=pipe=区域的内容，并输出给浏览器</li>
<li>chunck输出</li>
</ul>

<p>
具体使用可以下载<a href="https://github.com/fex-team/yog-app">示例</a>，跑一把就知道了。
</p>
</div>
</div>

<div id="outline-container-mvc封装" class="outline-4">
<h4 id="mvc封装">MVC封装</h4>
<div class="outline-text-4" id="text-mvc封装">
<p>
说到此处，<a href="https://github.com/fex-team/yog">yog</a>其实只负责了=view=和=controller=层，因为按照经验来看，=model=层迁移node阻力很大，暂时没有对这层的覆盖，后续会陆续搞定这层；
</p>

<p>
MVC封装比较简洁，=controller=兼职管理=router=的职务，并渲染=view=。
</p>
</div>
</div>

<div id="outline-container-目录规范" class="outline-4">
<h4 id="目录规范">目录规范</h4>
<div class="outline-text-4" id="text-目录规范">
<p>
这节说一下目录规范，其实这些都在<a href="http://oak.baidu.com/docs/yogurt">文档</a>中有详细的说明；
</p>

<div class="org-src-container">
<pre class="src src-sh">&#10140;  yog-app git:(master) &#10007; tree -L 1
.
&#9500;&#9472;&#9472; config
&#9500;&#9472;&#9472; controllers <span class="org-comment-delimiter"># </span><span class="org-comment">controller
</span>&#9500;&#9472;&#9472; models <span class="org-comment-delimiter"># </span><span class="org-comment">model
</span>&#9500;&#9472;&#9472; views  <span class="org-comment-delimiter"># </span><span class="org-comment">view
</span>&#9500;&#9472;&#9472; public    <span class="org-comment-delimiter"># </span><span class="org-comment">&#38745;&#24577;&#36164;&#28304;&#25991;&#20214;&#22841;
</span>&#9492;&#9472;&#9472; server.js <span class="org-comment-delimiter"># </span><span class="org-comment">&#20837;&#21475;&#25991;&#20214;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-开发模式" class="outline-4">
<h4 id="开发模式">开发模式</h4>
<div class="outline-text-4" id="text-开发模式">

<figure id="orgc03c3bd">
<img src="file:///images/dev/rd-fe.png" alt="rd-fe.png">

</figure>

<p>
如图，述说开发模式，不得不上一幅图；
</p>

<ul class="org-ul">
<li>RD 后端开发</li>
<li>FE 前端开发</li>
</ul>
</div>

<ul class="org-ul">
<li><a id="a开发模式"></a>A开发模式<br>
<div class="outline-text-5" id="text-a开发模式">
<p>
FE写完页面，然后把写好的页面交给RD进行模板化，也就是*模板*这个东西在RD手上，也就是归于*后端业务逻辑*
</p>

<p>
这种模式的不好的地方是，前端页面展现显然是经常会变化的，那么来回这么折腾，费时费力不说还费钱；
</p>

<p>
不过貌似很多公司都是*A开发模式*
</p>
</div>
</li>

<li><a id="b开发模式"></a>B开发模式<br>
<div class="outline-text-5" id="text-b开发模式">
<p>
为了解决上面的问题，出现了B开发模式，B开发模式是这样的；FE负责了写*模板*这个事情，每次迭代都很方便，有UI修改，只需要上模板就行，这时候一个频繁的工作由FE完成；
</p>

<p>
当然，这种开发模式也是有问题的；比如RD没有开发完成，FE就没有数据来测试自己的代码了；这时候需要一套本地模拟环境的工具；比如现在的<a href="http://oak.baidu.com/docs/fis-plus">fis-plus</a>就完美模拟了线上环境；
</p>

<p>
还有一个问题是啥呢，那就是每次还需要跟RD对接口，对数据结构，每次添加修改点数据也很麻烦；
</p>

<p>
到后来就出现了C开发模式
</p>
</div>
</li>

<li><a id="c开发模式"></a>C开发模式<br>
<div class="outline-text-5" id="text-c开发模式">
<p>
C开发模式就是建立*大前端*，FE负责UI层后端逻辑以及前端相关所有事物，这种模式相当不错，处理问题或者添加功能只需要FE来搞就行，没有了额外的沟通开销，开发顺畅了不少。
</p>

<p>
但，也许FE需要学习一门后端语言，当然这个不是问题；
</p>

<p>
<a href="https://github.com/fex-team/yog">yog</a>
专提供给FE同学的后端UI开发框架，不巧语言也是FE同学熟悉的JavaScript（nodejs），这样似乎可以方便的使用=C开发模式=。
</p>
</div>
</li>
</ul>
</div>
</section>

  </div>
</article>

 </main>

<hr/>
 
 <p class='disclaimer'></p>

  <p>Last updated 01 Dec 2025. Built with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.4 (<a href="https://orgmode.org/">Org</a> mode 9.6.15). <a href="https://www.orrafy.com/readme.html">Details</a>.</p>
  <script src="//unpkg.com/heti/umd/heti-addon.min.js"></script>
  <script>
    const heti = new Heti('.heti');
    heti.autoSpacing();
  </script>
</body>
</html>
